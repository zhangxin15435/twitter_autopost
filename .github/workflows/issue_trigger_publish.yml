name: üìù IssueËß¶ÂèëÊé®ÊñáÂèëÂ∏É

on:
  issues:
    types: [opened]

jobs:
  parse-and-publish:
    if: contains(github.event.issue.title, '[Êé®ÊñáÂèëÂ∏É]')
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Ê£ÄÂá∫‰ª£Á†Å
      uses: actions/checkout@v4
      
    - name: üêç ËÆæÁΩÆPythonÁéØÂ¢É
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: üì¶ ÂÆâË£Ö‰æùËµñ
      run: |
        pip install -r requirements.txt
        
    - name: üìù Ëß£ÊûêIssueÂÜÖÂÆπÂπ∂ÂèëÂ∏É
      env:
        # Twitter APIÂØÜÈí• - ContextSpace‰∏ªË¥¶Âè∑
        TWITTER_CONTEXTSPACE_CONSUMER_KEY: ${{ secrets.TWITTER_CONTEXTSPACE_CONSUMER_KEY }}
        TWITTER_CONTEXTSPACE_CONSUMER_SECRET: ${{ secrets.TWITTER_CONTEXTSPACE_CONSUMER_SECRET }}
        TWITTER_CONTEXTSPACE_ACCESS_TOKEN: ${{ secrets.TWITTER_CONTEXTSPACE_ACCESS_TOKEN }}
        TWITTER_CONTEXTSPACE_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_CONTEXTSPACE_ACCESS_TOKEN_SECRET }}
        TWITTER_CONTEXTSPACE_BEARER_TOKEN: ${{ secrets.TWITTER_CONTEXTSPACE_BEARER_TOKEN }}
        
        # OSS DiscoveriesË¥¶Âè∑
        TWITTER_OSSDISCOVERIES_CONSUMER_KEY: ${{ secrets.TWITTER_OSSDISCOVERIES_CONSUMER_KEY }}
        TWITTER_OSSDISCOVERIES_CONSUMER_SECRET: ${{ secrets.TWITTER_OSSDISCOVERIES_CONSUMER_SECRET }}
        TWITTER_OSSDISCOVERIES_ACCESS_TOKEN: ${{ secrets.TWITTER_OSSDISCOVERIES_ACCESS_TOKEN }}
        TWITTER_OSSDISCOVERIES_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_OSSDISCOVERIES_ACCESS_TOKEN_SECRET }}
        TWITTER_OSSDISCOVERIES_BEARER_TOKEN: ${{ secrets.TWITTER_OSSDISCOVERIES_BEARER_TOKEN }}
        
        # AI Flow WatchË¥¶Âè∑
        TWITTER_AIFLOWWATCH_CONSUMER_KEY: ${{ secrets.TWITTER_AIFLOWWATCH_CONSUMER_KEY }}
        TWITTER_AIFLOWWATCH_CONSUMER_SECRET: ${{ secrets.TWITTER_AIFLOWWATCH_CONSUMER_SECRET }}
        TWITTER_AIFLOWWATCH_ACCESS_TOKEN: ${{ secrets.TWITTER_AIFLOWWATCH_ACCESS_TOKEN }}
        TWITTER_AIFLOWWATCH_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_AIFLOWWATCH_ACCESS_TOKEN_SECRET }}
        TWITTER_AIFLOWWATCH_BEARER_TOKEN: ${{ secrets.TWITTER_AIFLOWWATCH_BEARER_TOKEN }}
        
        # Open Source ReaderË¥¶Âè∑
        TWITTER_OPENSOURCEREADER_CONSUMER_KEY: ${{ secrets.TWITTER_OPENSOURCEREADER_CONSUMER_KEY }}
        TWITTER_OPENSOURCEREADER_CONSUMER_SECRET: ${{ secrets.TWITTER_OPENSOURCEREADER_CONSUMER_SECRET }}
        TWITTER_OPENSOURCEREADER_ACCESS_TOKEN: ${{ secrets.TWITTER_OPENSOURCEREADER_ACCESS_TOKEN }}
        TWITTER_OPENSOURCEREADER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_OPENSOURCEREADER_ACCESS_TOKEN_SECRET }}
        TWITTER_OPENSOURCEREADER_BEARER_TOKEN: ${{ secrets.TWITTER_OPENSOURCEREADER_BEARER_TOKEN }}
        
      run: |
        python3 << 'EOF'
        import os
        import sys
        import json
        import re
        from main_multi_account import MultiAccountTwitterPublisher
        
        # Ëé∑ÂèñIssueÂÜÖÂÆπ
        issue_body = """${{ github.event.issue.body }}"""
        issue_number = "${{ github.event.issue.number }}"
        
        print(f"üîç Â§ÑÁêÜIssue #{issue_number}")
        print(f"üìù IssueÂÜÖÂÆπ: {issue_body[:100]}...")
        
        def parse_issue_content(content):
            """Ëß£ÊûêIssueÂÜÖÂÆπÔºåÊèêÂèñÊé®ÊñáÊï∞ÊçÆ"""
            tweets = []
            
            # ÊñπÊ≥ï1ÔºöJSONÊ†ºÂºè
            json_match = re.search(r'```json\n(.*?)\n```', content, re.DOTALL)
            if json_match:
                try:
                    data = json.loads(json_match.group(1))
                    if isinstance(data, list):
                        tweets.extend(data)
                    else:
                        tweets.append(data)
                    return tweets
                except:
                    pass
            
            # ÊñπÊ≥ï2ÔºöÁªìÊûÑÂåñÊñáÊú¨Ê†ºÂºè
            lines = content.split('\n')
            current_tweet = {}
            
            for line in lines:
                line = line.strip()
                if line.startswith('**ÂÜÖÂÆπ:**') or line.startswith('ÂÜÖÂÆπ:'):
                    current_tweet['content'] = line.split(':', 1)[1].strip()
                elif line.startswith('**Ë¥¶Âè∑:**') or line.startswith('Ë¥¶Âè∑:'):
                    current_tweet['account'] = line.split(':', 1)[1].strip()
                elif line.startswith('---') and current_tweet:
                    tweets.append(current_tweet)
                    current_tweet = {}
            
            # Ê∑ªÂä†ÊúÄÂêé‰∏ÄÊù°Êé®Êñá
            if current_tweet.get('content'):
                tweets.append(current_tweet)
            
            # ÊñπÊ≥ï3ÔºöÁÆÄÂçïÊ†ºÂºèÔºàÂ¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÁªìÊûÑÂåñÂÜÖÂÆπÔºâ
            if not tweets:
                # Êü•ÊâæÂèØËÉΩÁöÑÊé®ÊñáÂÜÖÂÆπ
                content_lines = [line.strip() for line in lines if line.strip() and not line.startswith('#')]
                if content_lines:
                    tweets.append({
                        'content': '\n'.join(content_lines[:3]),  # ÂèñÂâç3Ë°å‰Ωú‰∏∫ÂÜÖÂÆπ
                        'account': 'ContextSpace'  # ÈªòËÆ§Ë¥¶Âè∑
                    })
            
            return tweets
        
        def normalize_account_name(account):
            """Ê†áÂáÜÂåñË¥¶Âè∑ÂêçÁß∞"""
            account = account.lower().strip()
            mapping = {
                'contextspace': 'ContextSpace',
                'context space': 'ContextSpace',
                'twitter': 'ContextSpace',
                'oss discoveries': 'OSS Discoveries',
                'ossdiscoveries': 'OSS Discoveries',
                'oss': 'OSS Discoveries',
                'ai flow watch': 'Ai flow watch',
                'aiflowwatch': 'Ai flow watch',
                'ai': 'Ai flow watch',
                'open source reader': 'Open source reader',
                'opensourcereader': 'Open source reader',
                'reader': 'Open source reader'
            }
            return mapping.get(account, 'ContextSpace')
        
        try:
            # Ëß£ÊûêÊé®ÊñáÊï∞ÊçÆ
            tweets = parse_issue_content(issue_body)
            
            if not tweets:
                print("‚ùå Êú™ÊâæÂà∞ÊúâÊïàÁöÑÊé®ÊñáÂÜÖÂÆπ")
                sys.exit(1)
            
            print(f"‚úÖ Ëß£ÊûêÂà∞ {len(tweets)} Êù°Êé®Êñá")
            
            # ÂàùÂßãÂåñÂèëÂ∏ÉÂô®
            publisher = MultiAccountTwitterPublisher()
            
            # ÂèëÂ∏ÉÊé®Êñá
            success_count = 0
            for i, tweet in enumerate(tweets):
                content = tweet.get('content', '').strip()
                account = normalize_account_name(tweet.get('account', 'ContextSpace'))
                
                if not content:
                    print(f"‚ö†Ô∏è Á¨¨{i+1}Êù°Êé®ÊñáÂÜÖÂÆπ‰∏∫Á©∫ÔºåË∑≥Ëøá")
                    continue
                
                if len(content) > 280:
                    print(f"‚ö†Ô∏è Á¨¨{i+1}Êù°Êé®ÊñáÂÜÖÂÆπË∂ÖÈïø({len(content)}Â≠óÁ¨¶)ÔºåÊà™Êñ≠Â§ÑÁêÜ")
                    content = content[:277] + "..."
                
                print(f"üì§ ÂèëÂ∏ÉÁ¨¨{i+1}Êù°Êé®ÊñáÂà∞ {account}")
                print(f"üìù ÂÜÖÂÆπ: {content[:50]}...")
                
                try:
                    result = publisher.publish_single_tweet(content, account)
                    if result:
                        success_count += 1
                        print(f"‚úÖ Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÊàêÂäü")
                    else:
                        print(f"‚ùå Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÂ§±Ë¥•")
                except Exception as e:
                    print(f"üí• Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÂºÇÂ∏∏: {str(e)}")
            
            print(f"\nüéâ ÂèëÂ∏ÉÂÆåÊàê: {success_count}/{len(tweets)} Êù°ÊàêÂäü")
            
            # ËÆæÁΩÆËæìÂá∫ÂèòÈáèÁî®‰∫éÂêéÁª≠Ê≠•È™§
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write(f"success_count={success_count}\n")
                f.write(f"total_count={len(tweets)}\n")
                
        except Exception as e:
            print(f"üí• ÂèëÂ∏ÉËøáÁ®ãÂá∫Áé∞ÈîôËØØ: {str(e)}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
        EOF
        
    - name: üí¨ ÂõûÂ§çIssueÁªìÊûú
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const success_count = '${{ steps.parse-and-publish.outputs.success_count }}' || '0';
          const total_count = '${{ steps.parse-and-publish.outputs.total_count }}' || '0';
          
          let comment = '';
          if (success_count > 0) {
            comment = `üéâ **Êé®ÊñáÂèëÂ∏ÉÂÆåÊàêÔºÅ**\n\n‚úÖ ÊàêÂäüÂèëÂ∏É: ${success_count}/${total_count} Êù°Êé®Êñá\n\nüìä ÂèëÂ∏ÉÁªìÊûúÂ∑≤ËÆ∞ÂΩïÔºåÊÑüË∞¢ÊÇ®ÁöÑ‰ΩøÁî®ÔºÅ`;
          } else {
            comment = `‚ùå **Êé®ÊñáÂèëÂ∏ÉÂ§±Ë¥•**\n\nÂèØËÉΩÁöÑÂéüÂõ†Ôºö\n- Êé®ÊñáÂÜÖÂÆπÊ†ºÂºè‰∏çÊ≠£Á°Æ\n- Êé®ÊñáÂÜÖÂÆπ‰∏∫Á©∫\n- Twitter APIÈÖçÈ¢ùÂ∑≤Êª°\n- ÁΩëÁªúËøûÊé•ÈóÆÈ¢ò\n\nËØ∑Ê£ÄÊü•IssueÂÜÖÂÆπÊ†ºÂºèÂπ∂ÈáçËØï„ÄÇ`;
          }
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
    - name: üè∑Ô∏è Ê∑ªÂä†Ê†áÁ≠æ
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const success_count = '${{ steps.parse-and-publish.outputs.success_count }}' || '0';
          
          const label = success_count > 0 ? 'published' : 'failed';
          
          await github.rest.issues.addLabels({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: [label]
          }); 