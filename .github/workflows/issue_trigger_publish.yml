name: üìù IssueËß¶ÂèëÊé®ÊñáÂèëÂ∏É

on:
  issues:
    types: [opened]

jobs:
  parse-and-publish:
    if: contains(github.event.issue.title, '[Êé®ÊñáÂèëÂ∏É]')
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Ê£ÄÂá∫‰ª£Á†Å
      uses: actions/checkout@v4
      
    - name: üêç ËÆæÁΩÆPythonÁéØÂ¢É
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: üì¶ ÂÆâË£Ö‰æùËµñ
      run: |
        pip install -r requirements.txt
        
    - name: üìù Ëß£ÊûêIssueÂÜÖÂÆπÂπ∂ÂèëÂ∏É
      id: parse-and-publish
      env:
        # Twitter APIÂØÜÈí• - ContextSpace‰∏ªË¥¶Âè∑
        TWITTER_CONTEXTSPACE_CONSUMER_KEY: ${{ secrets.TWITTER_CONTEXTSPACE_CONSUMER_KEY }}
        TWITTER_CONTEXTSPACE_CONSUMER_SECRET: ${{ secrets.TWITTER_CONTEXTSPACE_CONSUMER_SECRET }}
        TWITTER_CONTEXTSPACE_ACCESS_TOKEN: ${{ secrets.TWITTER_CONTEXTSPACE_ACCESS_TOKEN }}
        TWITTER_CONTEXTSPACE_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_CONTEXTSPACE_ACCESS_TOKEN_SECRET }}
        TWITTER_CONTEXTSPACE_BEARER_TOKEN: ${{ secrets.TWITTER_CONTEXTSPACE_BEARER_TOKEN }}
        
        # OSS DiscoveriesË¥¶Âè∑
        TWITTER_OSSDISCOVERIES_CONSUMER_KEY: ${{ secrets.TWITTER_OSSDISCOVERIES_CONSUMER_KEY }}
        TWITTER_OSSDISCOVERIES_CONSUMER_SECRET: ${{ secrets.TWITTER_OSSDISCOVERIES_CONSUMER_SECRET }}
        TWITTER_OSSDISCOVERIES_ACCESS_TOKEN: ${{ secrets.TWITTER_OSSDISCOVERIES_ACCESS_TOKEN }}
        TWITTER_OSSDISCOVERIES_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_OSSDISCOVERIES_ACCESS_TOKEN_SECRET }}
        TWITTER_OSSDISCOVERIES_BEARER_TOKEN: ${{ secrets.TWITTER_OSSDISCOVERIES_BEARER_TOKEN }}
        
        # AI Flow WatchË¥¶Âè∑
        TWITTER_AIFLOWWATCH_CONSUMER_KEY: ${{ secrets.TWITTER_AIFLOWWATCH_CONSUMER_KEY }}
        TWITTER_AIFLOWWATCH_CONSUMER_SECRET: ${{ secrets.TWITTER_AIFLOWWATCH_CONSUMER_SECRET }}
        TWITTER_AIFLOWWATCH_ACCESS_TOKEN: ${{ secrets.TWITTER_AIFLOWWATCH_ACCESS_TOKEN }}
        TWITTER_AIFLOWWATCH_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_AIFLOWWATCH_ACCESS_TOKEN_SECRET }}
        TWITTER_AIFLOWWATCH_BEARER_TOKEN: ${{ secrets.TWITTER_AIFLOWWATCH_BEARER_TOKEN }}
        
        # Open Source ReaderË¥¶Âè∑
        TWITTER_OPENSOURCEREADER_CONSUMER_KEY: ${{ secrets.TWITTER_OPENSOURCEREADER_CONSUMER_KEY }}
        TWITTER_OPENSOURCEREADER_CONSUMER_SECRET: ${{ secrets.TWITTER_OPENSOURCEREADER_CONSUMER_SECRET }}
        TWITTER_OPENSOURCEREADER_ACCESS_TOKEN: ${{ secrets.TWITTER_OPENSOURCEREADER_ACCESS_TOKEN }}
        TWITTER_OPENSOURCEREADER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_OPENSOURCEREADER_ACCESS_TOKEN_SECRET }}
        TWITTER_OPENSOURCEREADER_BEARER_TOKEN: ${{ secrets.TWITTER_OPENSOURCEREADER_BEARER_TOKEN }}
        
      run: |
        python3 << 'EOF'
        import os
        import sys
        import json
        import re
        from main_multi_account import MultiAccountTwitterPublisher
        
        # Ëé∑ÂèñIssueÂÜÖÂÆπ
        issue_body = """${{ github.event.issue.body }}"""
        issue_number = "${{ github.event.issue.number }}"
        
        print(f"üîç Â§ÑÁêÜIssue #{issue_number}")
        print(f"üìù IssueÂÜÖÂÆπ: {issue_body[:100]}...")
        
        def parse_issue_content(content):
            """Ëß£ÊûêIssueÂÜÖÂÆπÔºåÊèêÂèñÊé®ÊñáÊï∞ÊçÆ"""
            tweets = []
            
            # ÊñπÊ≥ï1ÔºöJSONÊ†ºÂºè
            json_match = re.search(r'```json\n(.*?)\n```', content, re.DOTALL)
            if json_match:
                try:
                    data = json.loads(json_match.group(1))
                    if isinstance(data, list):
                        tweets.extend(data)
                    else:
                        tweets.append(data)
                    return tweets
                except:
                    pass
            
            # ÊñπÊ≥ï2ÔºöÁªìÊûÑÂåñÊñáÊú¨Ê†ºÂºè
            lines = content.split('\n')
            current_tweet = {}
            
            for line in lines:
                line = line.strip()
                if line.startswith('**ÂÜÖÂÆπ:**') or line.startswith('ÂÜÖÂÆπ:'):
                    content_text = line.split(':', 1)[1].strip()
                    # Ê∏ÖÁêÜÂèØËÉΩÁöÑÊòüÂè∑
                    content_text = content_text.lstrip('*').strip()
                    current_tweet['content'] = content_text
                elif line.startswith('**Ë¥¶Âè∑:**') or line.startswith('Ë¥¶Âè∑:'):
                    account_text = line.split(':', 1)[1].strip()
                    # Ê∏ÖÁêÜÂèØËÉΩÁöÑÊòüÂè∑
                    account_text = account_text.lstrip('*').strip()
                    current_tweet['account'] = account_text
                elif line.startswith('---') and current_tweet:
                    tweets.append(current_tweet)
                    current_tweet = {}
            
            # Ê∑ªÂä†ÊúÄÂêé‰∏ÄÊù°Êé®Êñá
            if current_tweet.get('content'):
                tweets.append(current_tweet)
            
            # ÊñπÊ≥ï3ÔºöÁÆÄÂçïÊ†ºÂºèÔºàÂ¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÁªìÊûÑÂåñÂÜÖÂÆπÔºâ
            if not tweets:
                # Êü•ÊâæÂèØËÉΩÁöÑÊé®ÊñáÂÜÖÂÆπ
                content_lines = [line.strip() for line in lines if line.strip() and not line.startswith('#')]
                if content_lines:
                    # ÂèñÊâÄÊúâÂÜÖÂÆπÔºå‰ΩÜÊ£ÄÊü•ÈïøÂ∫¶ÈôêÂà∂
                    full_content = '\n'.join(content_lines)
                    
                    # Â¶ÇÊûúÂÜÖÂÆπË∂ÖËøá280Â≠óÁ¨¶ÔºåÊà™Êñ≠Âπ∂Ê∑ªÂä†ÊèêÁ§∫
                    if len(full_content) > 280:
                        truncated_content = full_content[:270] + "...[ÂÜÖÂÆπËøáÈïøÂ∑≤Êà™Êñ≠]"
                        print(f"‚ö†Ô∏è ÂÜÖÂÆπË∂ÖÈïø({len(full_content)}Â≠óÁ¨¶)ÔºåÂ∑≤Êà™Êñ≠‰∏∫: {truncated_content}")
                        tweets.append({
                            'content': truncated_content,
                            'account': 'ContextSpace'  # ÈªòËÆ§Ë¥¶Âè∑
                        })
                    else:
                        tweets.append({
                            'content': full_content,
                            'account': 'ContextSpace'  # ÈªòËÆ§Ë¥¶Âè∑
                        })
            
            return tweets
        
        def normalize_account_name(account):
            """Ê†áÂáÜÂåñË¥¶Âè∑ÂêçÁß∞"""
            account = account.lower().strip()
            mapping = {
                'contextspace': 'ContextSpace',
                'context space': 'ContextSpace',
                'twitter': 'ContextSpace',
                'oss discoveries': 'OSS Discoveries',
                'ossdiscoveries': 'OSS Discoveries',
                'oss': 'OSS Discoveries',
                'ai flow watch': 'Ai flow watch',
                'aiflowwatch': 'Ai flow watch',
                'ai': 'Ai flow watch',
                'open source reader': 'Open source reader',
                'opensourcereader': 'Open source reader',
                'reader': 'Open source reader'
            }
            return mapping.get(account, 'ContextSpace')
        
        try:
            # Ëß£ÊûêÊé®ÊñáÊï∞ÊçÆ
            tweets = parse_issue_content(issue_body)
            
            if not tweets:
                print("‚ùå Êú™ÊâæÂà∞ÊúâÊïàÁöÑÊé®ÊñáÂÜÖÂÆπ")
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write("success_count=0\n")
                    f.write("total_count=0\n")
                    f.write("error_message=Êé®ÊñáÂÜÖÂÆπÊ†ºÂºè‰∏çÊ≠£Á°ÆÊàñ‰∏∫Á©∫\n")
                sys.exit(0)  # ‰∏çË¶ÅÂ§±Ë¥•ÈÄÄÂá∫ÔºåËÆ©ÂêéÁª≠Ê≠•È™§Â§ÑÁêÜ
            
            print(f"‚úÖ Ëß£ÊûêÂà∞ {len(tweets)} Êù°Êé®Êñá")
            
            # ÂàùÂßãÂåñÂèëÂ∏ÉÂô®
            publisher = MultiAccountTwitterPublisher()
            
            # ÂèëÂ∏ÉÊé®Êñá
            success_count = 0
            error_messages = []
            
            for i, tweet in enumerate(tweets):
                content = tweet.get('content', '').strip()
                account = normalize_account_name(tweet.get('account', 'ContextSpace'))
                
                if not content:
                    print(f"‚ö†Ô∏è Á¨¨{i+1}Êù°Êé®ÊñáÂÜÖÂÆπ‰∏∫Á©∫ÔºåË∑≥Ëøá")
                    continue
                
                if len(content) > 280:
                    print(f"‚ö†Ô∏è Á¨¨{i+1}Êù°Êé®ÊñáÂÜÖÂÆπË∂ÖÈïø({len(content)}Â≠óÁ¨¶)ÔºåÊà™Êñ≠Â§ÑÁêÜ")
                    content = content[:277] + "..."
                
                print(f"üì§ ÂèëÂ∏ÉÁ¨¨{i+1}Êù°Êé®ÊñáÂà∞ {account}")
                print(f"üìù ÂÜÖÂÆπ: {content[:50]}...")
                
                try:
                    # ‰ΩøÁî®ÂçïË¥¶Âè∑Á´ãÂç≥ÂèëÂ∏ÉÊ®°ÂºèÔºåÈÅøÂÖçÂØπÂÖ∂‰ªñË¥¶Âè∑ÂèëÈÄÅAPIËØ∑Ê±Ç
                    result = publisher.publish_single_tweet_only(content, account)
                    if result['success']:
                        success_count += 1
                        print(f"‚úÖ Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÊàêÂäü")
                        print(f"   Ë¥¶Âè∑: {result['details'].get('username', 'unknown')}")
                    else:
                        error_msg = f"Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÂ§±Ë¥•: {result['message']}"
                        print(f"‚ùå {error_msg}")
                        error_messages.append(error_msg)
                except Exception as e:
                    error_msg = f"Á¨¨{i+1}Êù°Êé®ÊñáÂèëÂ∏ÉÂºÇÂ∏∏: {str(e)}"
                    print(f"üí• {error_msg}")
                    error_messages.append(error_msg)
                    
                    # Ê£ÄÊü•ÊòØÂê¶ÊòØÈÄüÁéáÈôêÂà∂ÈîôËØØ
                    if "rate limit" in str(e).lower() or "too many requests" in str(e).lower():
                        print("‚ö†Ô∏è Ê£ÄÊµãÂà∞Twitter APIÈÄüÁéáÈôêÂà∂ÔºåÂÅúÊ≠¢ÂêéÁª≠ÂèëÂ∏É")
                        error_messages.append("Twitter APIÈÄüÁéáÈôêÂà∂ÔºåËØ∑Á®çÂêéÈáçËØï")
                        break
            
            print(f"\nüéâ ÂèëÂ∏ÉÂÆåÊàê: {success_count}/{len(tweets)} Êù°ÊàêÂäü")
            
            # ËÆæÁΩÆËæìÂá∫ÂèòÈáèÁî®‰∫éÂêéÁª≠Ê≠•È™§
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write(f"success_count={success_count}\n")
                f.write(f"total_count={len(tweets)}\n")
                if error_messages:
                    f.write(f"error_message={'; '.join(error_messages[:3])}\n")  # Âè™ÂèñÂâç3‰∏™ÈîôËØØ
                
        except Exception as e:
            error_msg = f"ÂèëÂ∏ÉËøáÁ®ãÂá∫Áé∞ÈîôËØØ: {str(e)}"
            print(f"üí• {error_msg}")
            import traceback
            traceback.print_exc()
            
            # ËÆæÁΩÆÈîôËØØËæìÂá∫
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("success_count=0\n")
                f.write("total_count=0\n")
                f.write(f"error_message={error_msg}\n")
            sys.exit(0)  # ‰∏çË¶ÅÂ§±Ë¥•ÈÄÄÂá∫ÔºåËÆ©ÂêéÁª≠Ê≠•È™§Â§ÑÁêÜ
        EOF
        
    - name: üí¨ ÂõûÂ§çIssueÁªìÊûú
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const success_count = '${{ steps.parse-and-publish.outputs.success_count }}' || '0';
          const total_count = '${{ steps.parse-and-publish.outputs.total_count }}' || '0';
          const error_message = '${{ steps.parse-and-publish.outputs.error_message }}' || '';
          
          let comment = '';
          
          if (success_count > 0) {
            if (success_count == total_count) {
              comment = `üéâ **Êé®ÊñáÂèëÂ∏ÉÂÆåÊàêÔºÅ**\n\n‚úÖ ÊàêÂäüÂèëÂ∏É: ${success_count}/${total_count} Êù°Êé®Êñá\n\nüìä ÂèëÂ∏ÉÁªìÊûúÂ∑≤ËÆ∞ÂΩïÔºåÊÑüË∞¢ÊÇ®ÁöÑ‰ΩøÁî®ÔºÅ`;
            } else {
              comment = `‚ö†Ô∏è **Êé®ÊñáÈÉ®ÂàÜÂèëÂ∏ÉÊàêÂäü**\n\n‚úÖ ÊàêÂäüÂèëÂ∏É: ${success_count}/${total_count} Êù°Êé®Êñá\n\n‚ùå ÈÉ®ÂàÜÂ§±Ë¥•ÂéüÂõ†: ${error_message}\n\nüí° Âª∫ËÆÆÁ®çÂêéÈáçËØïÂ§±Ë¥•ÁöÑÂÜÖÂÆπ„ÄÇ`;
            }
          } else if (error_message.includes('ÈÄüÁéáÈôêÂà∂') || error_message.includes('rate limit')) {
            comment = `‚è±Ô∏è **Twitter APIÈÄüÁéáÈôêÂà∂**\n\nüòÖ Êä±Ê≠âÔºåÈÅáÂà∞‰∫ÜTwitter APIÁöÑÈÄüÁéáÈôêÂà∂ÔºåËøôÊòØÊ≠£Â∏∏ÁöÑ‰øùÊä§Êú∫Âà∂„ÄÇ\n\nüîÑ **Ëß£ÂÜ≥ÊñπÊ°à**:\n- ËØ∑Á≠âÂæÖ10-15ÂàÜÈíüÂêéÈáçÊñ∞ÂàõÂª∫Issue\n- ÊàñËÄÖÁ®çÂêé‰ΩøÁî®ÂâçÁ´ØÁïåÈù¢ÂèëÂ∏É\n- Ëøô‰∏™ÈôêÂà∂‰ºöËá™Âä®ÊÅ¢Â§çÔºåÊó†ÈúÄÊãÖÂøÉ\n\nüìã **ÊÇ®ÁöÑÂÜÖÂÆπÂ∑≤ËÆ∞ÂΩï**ÔºåÁ®çÂêéÂèØ‰ª•ÈáçËØïÂèëÂ∏É„ÄÇ`;
          } else if (error_message.includes('Ê†ºÂºè')) {
            comment = `üìù **Êé®ÊñáÊ†ºÂºèÈóÆÈ¢ò**\n\n‚ùå ÂèëÂ∏ÉÂ§±Ë¥•ÂéüÂõ†: ${error_message}\n\n‚úÖ **Ê≠£Á°ÆÊ†ºÂºè**:\n\`\`\`\n**ÂÜÖÂÆπ:** ÊÇ®ÁöÑÊé®ÊñáÂÜÖÂÆπ\n**Ë¥¶Âè∑:** ContextSpace\n\`\`\`\n\nüéØ **ÊîØÊåÅÁöÑË¥¶Âè∑**:\n- ContextSpace (‰∏ªË¥¶Âè∑)\n- OSS Discoveries (ÂºÄÊ∫êÂ∑•ÂÖ∑)\n- AI Flow Watch (AIÊäÄÊúØ)\n- Open Source Reader (ÂºÄÊ∫êÈ°πÁõÆ)\n\nËØ∑ÊåâÊ≠£Á°ÆÊ†ºÂºèÈáçÊñ∞ÂàõÂª∫Issue„ÄÇ`;
          } else {
            comment = `‚ùå **Êé®ÊñáÂèëÂ∏ÉÂ§±Ë¥•**\n\nüîç **Â§±Ë¥•ÂéüÂõ†**: ${error_message || 'Êú™Áü•ÈîôËØØ'}\n\nüõ†Ô∏è **ÂèØËÉΩÁöÑËß£ÂÜ≥ÊñπÊ°à**:\n- Ê£ÄÊü•Êé®ÊñáÂÜÖÂÆπÊ†ºÂºèÊòØÂê¶Ê≠£Á°Æ\n- Á°ÆËÆ§Êé®ÊñáÂÜÖÂÆπ‰∏çË∂ÖËøá280Â≠óÁ¨¶\n- Ê£ÄÊü•Ë¥¶Âè∑ÂêçÁß∞ÊòØÂê¶Ê≠£Á°Æ\n- Á®çÂêéÈáçËØïÔºàÂèØËÉΩÊòØ‰∏¥Êó∂ÁΩëÁªúÈóÆÈ¢òÔºâ\n\nüìã Â¶ÇÊûúÈóÆÈ¢òÊåÅÁª≠ÔºåËØ∑Êü•Áúã [‰ΩøÁî®ÊåáÂçó](https://github.com/zhangxin15435/twitter_autopost/blob/master/ISSUE_PUBLISH_GUIDE.md)„ÄÇ`;
          }
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
    - name: üè∑Ô∏è Ê∑ªÂä†Ê†áÁ≠æ
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const success_count = '${{ steps.parse-and-publish.outputs.success_count }}' || '0';
          const total_count = '${{ steps.parse-and-publish.outputs.total_count }}' || '0';
          const error_message = '${{ steps.parse-and-publish.outputs.error_message }}' || '';
          
          let labels = [];
          
          if (success_count > 0) {
            if (success_count == total_count) {
              labels = ['published'];
            } else {
              labels = ['partially-published'];
            }
          } else if (error_message.includes('ÈÄüÁéáÈôêÂà∂') || error_message.includes('rate limit')) {
            labels = ['rate-limited'];
          } else if (error_message.includes('Ê†ºÂºè')) {
            labels = ['format-error'];
          } else {
            labels = ['failed'];
          }
          
          // ÁßªÈô§pendingÊ†áÁ≠æ
          try {
            await github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'pending'
            });
          } catch (error) {
            // Â¶ÇÊûúpendingÊ†áÁ≠æ‰∏çÂ≠òÂú®ÔºåÂøΩÁï•ÈîôËØØ
          }
          
          // Ê∑ªÂä†Êñ∞Ê†áÁ≠æ
          await github.rest.issues.addLabels({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: labels
          }); 